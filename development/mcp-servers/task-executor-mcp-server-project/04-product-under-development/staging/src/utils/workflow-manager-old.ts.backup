/**
 * Workflow Manager - Core logic for managing task execution workflows
 */

import * as fs from 'fs';
import * as path from 'path';
import {
  WorkflowState,
  Task,
  TaskInput,
  CreateWorkflowInput,
  WorkflowContext,
  WorkflowDocumentation,
  VerificationReport,
  VerificationStatus
} from '../types.js';
import { ComplexityAnalyzer } from './complexity-analyzer.js';

export class WorkflowManager {
  /**
   * Get workflow directory path
   */
  private static getWorkflowPath(projectPath: string, workflowName: string, archived = false): string {
    const baseDir = archived ? 'archive' : 'temp';
    const timestamp = archived ? new Date().toISOString().split('T')[0] + '-' : '';
    return path.join(projectPath, baseDir, 'workflows', timestamp + workflowName);
  }

  /**
   * Get state file path
   */
  private static getStateFilePath(projectPath: string, workflowName: string, archived = false): string {
    const workflowPath = this.getWorkflowPath(projectPath, workflowName, archived);
    return path.join(workflowPath, 'state.json');
  }

  /**
   * Create a new workflow
   */
  static create(input: CreateWorkflowInput): { success: boolean; workflowPath?: string; error?: string; summary?: any } {
    try {
      const { name, projectPath, tasks: taskInputs, constraints = [], context = {} } = input;

      // Create workflow directory
      const workflowPath = this.getWorkflowPath(projectPath, name);
      if (fs.existsSync(workflowPath)) {
        return {
          success: false,
          error: `Workflow "${name}" already exists in temp/workflows/`
        };
      }

      fs.mkdirSync(workflowPath, { recursive: true });
      fs.mkdirSync(path.join(workflowPath, 'artifacts'), { recursive: true });

      // Create tasks with complexity analysis
      const tasks: Task[] = taskInputs.map((taskInput, index) => {
        const factors = ComplexityAnalyzer.estimateFromDescription(taskInput.description, context);
        if (taskInput.estimatedHours) {
          factors.estimatedHours = taskInput.estimatedHours;
        }

        const complexityResult = ComplexityAnalyzer.analyze(factors);

        return {
          id: String(index + 1),
          description: taskInput.description,
          status: 'pending',
          complexity: {
            score: complexityResult.score,
            level: complexityResult.level,
            emoji: ComplexityAnalyzer.getComplexityEmoji(complexityResult.level)
          },
          estimatedHours: taskInput.estimatedHours
        };
      });

      // Calculate total estimated hours
      const estimatedHours = tasks.reduce((sum, task) => sum + (task.estimatedHours || 0), 0);

      // Detect existing documentation
      const documentation = this.detectDocumentation(projectPath);

      // Create workflow state
      const state: WorkflowState = {
        name,
        created: new Date(),
        projectPath,
        status: 'active',
        tasks,
        constraints,
        context: {
          ...context,
          estimatedHours
        },
        documentation,
        metadata: {
          totalTasks: tasks.length,
          completedTasks: 0,
          verifiedTasks: 0,
          percentComplete: 0,
          lastUpdated: new Date()
        }
      };

      // Save state
      this.saveState(state, projectPath, name);

      // Generate plan.md
      this.generatePlan(state, workflowPath);

      return {
        success: true,
        workflowPath,
        summary: {
          totalTasks: tasks.length,
          estimatedHours,
          complexityScores: tasks.map(t => t.complexity?.score || 0)
        }
      };
    } catch (error) {
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * Load workflow state
   */
  static loadState(projectPath: string, workflowName: string, archived = false): WorkflowState | null {
    try {
      const stateFilePath = this.getStateFilePath(projectPath, workflowName, archived);

      if (!fs.existsSync(stateFilePath)) {
        return null;
      }

      const content = fs.readFileSync(stateFilePath, 'utf-8');
      const data = JSON.parse(content);

      // Parse dates
      data.created = new Date(data.created);
      data.metadata.lastUpdated = new Date(data.metadata.lastUpdated);
      data.tasks.forEach((task: Task) => {
        if (task.startedAt) task.startedAt = new Date(task.startedAt);
        if (task.completedAt) task.completedAt = new Date(task.completedAt);
        if (task.verifiedAt) task.verifiedAt = new Date(task.verifiedAt);
      });

      return data;
    } catch (error) {
      console.error('Error loading workflow state:', error);
      return null;
    }
  }

  /**
   * Save workflow state
   */
  private static saveState(state: WorkflowState, projectPath: string, workflowName: string, archived = false): void {
    const stateFilePath = this.getStateFilePath(projectPath, workflowName, archived);
    fs.writeFileSync(stateFilePath, JSON.stringify(state, null, 2), 'utf-8');
  }

  /**
   * Complete a task
   */
  static completeTask(
    projectPath: string,
    workflowName: string,
    taskId: string,
    notes?: string,
    skipVerification = false
  ): { success: boolean; task?: Task; progress?: any; verification?: VerificationReport; error?: string } {
    try {
      const state = this.loadState(projectPath, workflowName);

      if (!state) {
        return {
          success: false,
          error: `Workflow "${workflowName}" not found`
        };
      }

      const task = state.tasks.find(t => t.id === taskId);

      if (!task) {
        return {
          success: false,
          error: `Task ${taskId} not found in workflow`
        };
      }

      // Update task
      if (task.status === 'pending') {
        task.startedAt = new Date();
        task.status = 'in-progress';
      }

      task.completedAt = new Date();
      task.status = 'completed';
      if (notes) {
        task.notes = notes;
      }

      // Verification (simplified for MVP - no actual agent yet)
      let verification: VerificationReport | undefined;
      if (!skipVerification) {
        verification = this.performBasicVerification(task, state);
        task.verification = verification;

        if (verification.status === 'verified') {
          task.status = 'verified';
          task.verifiedAt = new Date();
        }
      }

      // Update metadata
      state.metadata.completedTasks = state.tasks.filter(t => t.status === 'completed' || t.status === 'verified').length;
      state.metadata.verifiedTasks = state.tasks.filter(t => t.status === 'verified').length;
      state.metadata.percentComplete = Math.round((state.metadata.completedTasks / state.metadata.totalTasks) * 100);
      state.metadata.lastUpdated = new Date();

      // Save
      this.saveState(state, projectPath, workflowName);

      // Regenerate plan
      const workflowPath = this.getWorkflowPath(projectPath, workflowName);
      this.generatePlan(state, workflowPath);

      return {
        success: true,
        task,
        verification,
        progress: {
          completed: state.metadata.completedTasks,
          total: state.metadata.totalTasks,
          percentComplete: state.metadata.percentComplete
        }
      };
    } catch (error) {
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * Basic verification (will be enhanced with agent integration)
   */
  private static performBasicVerification(task: Task, state: WorkflowState): VerificationReport {
    const evidence: string[] = [];
    const concerns: string[] = [];
    const recommendations: string[] = [];

    // Basic checks
    if (task.notes) {
      evidence.push(`Task notes provided: ${task.notes.substring(0, 100)}...`);
    } else {
      concerns.push('No completion notes provided');
      recommendations.push('Add notes explaining how the task was completed');
    }

    if (task.completedAt) {
      evidence.push(`Task marked complete at ${task.completedAt.toISOString()}`);
    }

    // Determine status
    let status: VerificationStatus = 'verified';
    if (concerns.length > 0) {
      status = 'partial';
    }

    return {
      status,
      evidence,
      concerns,
      recommendations
    };
  }

  /**
   * Get workflow status
   */
  static getStatus(projectPath: string, workflowName: string): any {
    try {
      const state = this.loadState(projectPath, workflowName);

      if (!state) {
        return {
          success: false,
          error: `Workflow "${workflowName}" not found`
        };
      }

      // Find next pending task
      const nextTask = state.tasks.find(t => t.status === 'pending');

      return {
        success: true,
        workflow: {
          name: state.name,
          created: state.created,
          status: state.status,
          progress: `${state.metadata.percentComplete}% (${state.metadata.completedTasks}/${state.metadata.totalTasks} tasks)`,
          nextTask: nextTask ? `${nextTask.id}. ${nextTask.description}` : 'All tasks completed!',
          constraintsStatus: this.getConstraintsStatus(state)
        },
        tasks: state.tasks.map(t => ({
          id: t.id,
          description: t.description,
          status: t.status,
          complexity: t.complexity
        })),
        documentation: state.documentation
      };
    } catch (error) {
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * Archive workflow
   */
  static archive(projectPath: string, workflowName: string, force = false): any {
    try {
      const state = this.loadState(projectPath, workflowName);

      if (!state) {
        return {
          success: false,
          error: `Workflow "${workflowName}" not found`
        };
      }

      // Validation
      const validation = {
        allTasksComplete: state.metadata.completedTasks === state.metadata.totalTasks,
        allConstraintsMet: true, // TODO: Implement constraint checking
        documentationUpdated: state.documentation.updated.length === state.documentation.needsUpdate.length,
        noTempFiles: true // TODO: Implement temp file detection
      };

      if (!force) {
        if (!validation.allTasksComplete) {
          return {
            success: false,
            error: `Cannot archive: ${state.metadata.totalTasks - state.metadata.completedTasks} tasks still pending`,
            validation
          };
        }
      }

      // Move from temp to archive
      const tempPath = this.getWorkflowPath(projectPath, workflowName, false);
      const archivePath = this.getWorkflowPath(projectPath, workflowName, true);

      // Create archive directory
      fs.mkdirSync(path.dirname(archivePath), { recursive: true });

      // Move directory
      fs.renameSync(tempPath, archivePath);

      // Update state
      state.status = 'archived';
      state.metadata.lastUpdated = new Date();

      // Save in archive location
      const archiveStateFile = path.join(archivePath, 'state.json');
      fs.writeFileSync(archiveStateFile, JSON.stringify(state, null, 2), 'utf-8');

      return {
        success: true,
        validation,
        archivePath
      };
    } catch (error) {
      return {
        success: false,
        error: String(error)
      };
    }
  }

  /**
   * Detect existing documentation in project
   */
  private static detectDocumentation(projectPath: string): WorkflowDocumentation {
    const existing: string[] = [];

    const commonDocs = ['README.md', 'CHANGELOG.md', 'API.md', 'CONTRIBUTING.md', 'docs/'];

    commonDocs.forEach(doc => {
      const docPath = path.join(projectPath, doc);
      if (fs.existsSync(docPath)) {
        existing.push(doc);
      }
    });

    return {
      existing,
      needsUpdate: [],
      updated: []
    };
  }

  /**
   * Get constraints status
   */
  private static getConstraintsStatus(state: WorkflowState): string {
    if (state.constraints.length === 0) {
      return 'No constraints defined';
    }

    return `${state.constraints.length} constraints to maintain`;
  }

  /**
   * Generate plan.md file
   */
  private static generatePlan(state: WorkflowState, workflowPath: string): void {
    let content = `# Workflow: ${state.name}\n\n`;
    content += `**Created**: ${state.created.toISOString().split('T')[0]}\n`;
    content += `**Status**: ${state.status}\n`;
    content += `**Progress**: ${state.metadata.percentComplete}% (${state.metadata.completedTasks}/${state.metadata.totalTasks} tasks)\n`;
    content += `**Location**: \`${workflowPath.split('/').slice(-3).join('/')}\`\n\n`;

    // Constraints
    if (state.constraints.length > 0) {
      content += `## Constraints\n\n`;
      state.constraints.forEach(constraint => {
        content += `- ${constraint}\n`;
      });
      content += `\n`;
    }

    // Tasks
    content += `## Tasks\n\n`;
    state.tasks.forEach(task => {
      const symbol = this.getTaskSymbol(task.status);
      const complexityBadge = task.complexity ? ` ${task.complexity.emoji} (${task.complexity.score}/10)` : '';
      content += `${symbol} ${task.id}. ${task.description}${complexityBadge}\n`;

      if (task.estimatedHours) {
        content += `   - Estimated: ${task.estimatedHours} hours\n`;
      }

      if (task.notes) {
        content += `   - Notes: ${task.notes}\n`;
      }

      if (task.verification) {
        content += `   - Verification: ${task.verification.status}\n`;
      }
    });
    content += `\n`;

    // Documentation
    if (state.documentation.existing.length > 0) {
      content += `## Documentation\n\n`;

      if (state.documentation.existing.length > 0) {
        content += `**Existing documentation**:\n`;
        state.documentation.existing.forEach(doc => {
          content += `- ${doc}\n`;
        });
        content += `\n`;
      }

      if (state.documentation.needsUpdate.length > 0) {
        content += `**Needs updating**:\n`;
        state.documentation.needsUpdate.forEach(doc => {
          const updated = state.documentation.updated.includes(doc);
          const symbol = updated ? '[x]' : '[ ]';
          content += `${symbol} ${doc}\n`;
        });
        content += `\n`;
      }
    }

    // Verification Checklist
    content += `## Verification Checklist\n\n`;
    const allTasksComplete = state.metadata.completedTasks === state.metadata.totalTasks;
    const allDocsUpdated = state.documentation.updated.length === state.documentation.needsUpdate.length;

    content += `${allTasksComplete ? '[x]' : '[ ]'} All tasks completed\n`;
    content += `[ ] All constraints satisfied\n`;
    content += `${allDocsUpdated ? '[x]' : '[ ]'} Documentation updated\n`;
    content += `[ ] No temporary files left\n`;
    content += `[ ] Ready to archive\n`;

    fs.writeFileSync(path.join(workflowPath, 'plan.md'), content, 'utf-8');
  }

  /**
   * Get task status symbol
   */
  private static getTaskSymbol(status: string): string {
    switch (status) {
      case 'pending': return '[ ]';
      case 'in-progress': return '[~]';
      case 'completed': return '[x]';
      case 'verified': return '[âœ“]';
      default: return '[ ]';
    }
  }
}
