/**
 * Analytics Tools
 * Generate insights and reports from telemetry data
 */
import { readFileSync, writeFileSync, existsSync, mkdirSync } from "fs";
import { join } from "path";
// Ensure directory exists
function ensureDir(dirPath) {
    if (!existsSync(dirPath)) {
        mkdirSync(dirPath, { recursive: true, mode: 0o700 });
    }
}
// Read all telemetry events
function readAllEvents(brainPath) {
    const telemetryDir = join(brainPath, "telemetry");
    if (!existsSync(telemetryDir)) {
        return [];
    }
    const events = [];
    const files = ["task-log.jsonl", "mcp-usage.jsonl"];
    for (const file of files) {
        const filePath = join(telemetryDir, file);
        if (existsSync(filePath)) {
            const content = readFileSync(filePath, "utf-8");
            const lines = content.trim().split("\n").filter(line => line.length > 0);
            for (const line of lines) {
                try {
                    events.push(JSON.parse(line));
                }
                catch (error) {
                    console.error(`Skipping malformed line in ${file}`);
                }
            }
        }
    }
    return events;
}
// Filter events by time range
function filterEventsByTimeRange(events, start, end) {
    return events.filter(event => {
        const eventTime = new Date(event.timestamp);
        return eventTime >= start && eventTime <= end;
    });
}
/**
 * Generate Weekly Summary
 * Create analytics report for a week
 */
export async function generateWeeklySummary(args, brainPath) {
    try {
        // Determine week start (default: last Monday)
        let weekStart;
        if (args.week_start) {
            weekStart = new Date(args.week_start);
        }
        else {
            const now = new Date();
            const dayOfWeek = now.getDay();
            const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
            weekStart = new Date(now);
            weekStart.setDate(now.getDate() - daysToMonday - 7); // Last Monday
            weekStart.setHours(0, 0, 0, 0);
        }
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekStart.getDate() + 7);
        // Get week number
        const weekNum = getWeekNumber(weekStart);
        const year = weekStart.getFullYear();
        // Read and filter events
        const allEvents = readAllEvents(brainPath);
        const weekEvents = filterEventsByTimeRange(allEvents, weekStart, weekEnd);
        // Calculate statistics
        const taskEvents = weekEvents.filter(e => e.type === "task" || e.type === "workflow");
        const totalTasks = taskEvents.length;
        const totalHours = taskEvents.reduce((sum, e) => sum + (e.data.duration_minutes || 0), 0) / 60;
        // Find most common task
        const taskTypeCounts = {};
        taskEvents.forEach(e => {
            const type = e.data.task_type || "unknown";
            taskTypeCounts[type] = (taskTypeCounts[type] || 0) + 1;
        });
        const mostCommonTask = Object.entries(taskTypeCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || "none";
        // Tool usage
        const toolCounts = {};
        taskEvents.forEach(e => {
            const tools = e.data.tools_used || [];
            tools.forEach((tool) => {
                toolCounts[tool] = (toolCounts[tool] || 0) + 1;
            });
        });
        const topTools = Object.entries(toolCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .map(([tool, count]) => `${tool} (${count})`);
        // Output format
        const outputFormat = args.output_format || "markdown";
        let summary;
        if (outputFormat === "markdown") {
            summary = `# Week ${weekNum} (${year}) Task Analysis

**Period:** ${weekStart.toISOString().split("T")[0]} to ${weekEnd.toISOString().split("T")[0]}

## Summary

- **Total tasks:** ${totalTasks}
- **Total time:** ${totalHours.toFixed(1)} hours
- **Most common task:** ${mostCommonTask} (${taskTypeCounts[mostCommonTask] || 0} times)
- **Average task duration:** ${totalTasks > 0 ? (totalHours * 60 / totalTasks).toFixed(1) : 0} minutes

## Top Tools Used

${topTools.map((t, i) => `${i + 1}. ${t}`).join("\n")}

## Task Type Distribution

${Object.entries(taskTypeCounts)
                .sort((a, b) => b[1] - a[1])
                .map(([type, count]) => `- ${type}: ${count} tasks (${(count * 100 / totalTasks).toFixed(1)}%)`)
                .join("\n")}

## Automation Opportunities

${totalTasks < 3 ? "Not enough data yet - need at least 3 tasks to identify patterns." : "Run get_automation_opportunities tool for detailed analysis."}

---

*Generated by workspace-brain MCP on ${new Date().toISOString()}*
`;
        }
        else {
            // JSON format
            summary = JSON.stringify({
                week: weekNum,
                year,
                period: {
                    start: weekStart.toISOString(),
                    end: weekEnd.toISOString()
                },
                summary: {
                    total_tasks: totalTasks,
                    total_hours: totalHours,
                    most_common_task: mostCommonTask,
                    avg_duration_minutes: totalTasks > 0 ? totalHours * 60 / totalTasks : 0
                },
                top_tools: topTools,
                task_distribution: taskTypeCounts
            }, null, 2);
        }
        // Save to file
        const summariesDir = join(brainPath, "analytics", "weekly-summaries");
        ensureDir(summariesDir);
        const filename = `${year}-W${weekNum.toString().padStart(2, "0")}.${outputFormat === "markdown" ? "md" : "json"}`;
        const filePath = join(summariesDir, filename);
        writeFileSync(filePath, summary, { mode: 0o600 });
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        summary,
                        file_path: filePath,
                        stats: {
                            total_tasks: totalTasks,
                            total_time_hours: totalHours,
                            most_common_task: mostCommonTask,
                            automation_opportunities: 0 // Placeholder
                        }
                    }, null, 2),
                },
            ],
        };
    }
    catch (error) {
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: false,
                        error: `Failed to generate weekly summary: ${error.message}`
                    }, null, 2)
                }
            ],
            isError: true
        };
    }
}
/**
 * Get Automation Opportunities
 * Find high-value automation targets based on frequency and duration
 */
export async function getAutomationOpportunities(args, brainPath) {
    try {
        // Read events
        let events = readAllEvents(brainPath);
        // Apply time range filter
        if (args.time_range) {
            const start = args.time_range.start ? new Date(args.time_range.start) : new Date(0);
            const end = args.time_range.end ? new Date(args.time_range.end) : new Date();
            events = filterEventsByTimeRange(events, start, end);
        }
        const taskEvents = events.filter(e => e.type === "task" || e.type === "workflow");
        // Group by pattern (task_type + tools_used)
        const patterns = {};
        taskEvents.forEach(event => {
            const taskType = event.data.task_type || "unknown";
            const tools = (event.data.tools_used || []).sort().join("+");
            const patternKey = `${taskType}::${tools}`;
            if (!patterns[patternKey]) {
                patterns[patternKey] = {
                    task_type: taskType,
                    tools: event.data.tools_used || [],
                    occurrences: 0,
                    total_duration: 0,
                    complexities: []
                };
            }
            patterns[patternKey].occurrences++;
            patterns[patternKey].total_duration += event.data.duration_minutes || 0;
            if (event.data.complexity) {
                patterns[patternKey].complexities.push(event.data.complexity);
            }
        });
        // Filter and score opportunities
        const minFrequency = args.min_frequency || 3;
        const minDuration = args.min_duration || 15;
        const opportunities = Object.values(patterns)
            .filter(p => p.occurrences >= minFrequency && (p.total_duration / p.occurrences) >= minDuration)
            .map(p => {
            const avgDuration = p.total_duration / p.occurrences;
            const avgComplexity = p.complexities.length > 0
                ? p.complexities.reduce((a, b) => a + b, 0) / p.complexities.length
                : 5; // Default medium complexity
            // Scoring: frequency * avg_duration * (1 - complexity/10)
            const score = p.occurrences * avgDuration * (1 - avgComplexity / 10);
            const estimatedSavings = (p.occurrences * avgDuration * 0.7) / 60; // 70% time savings
            return {
                pattern: p.task_type,
                type: p.tools.length >= 3 ? "orchestrator" : "skill",
                priority: score > 500 ? "high" : score > 200 ? "medium" : "low",
                frequency: p.occurrences,
                avg_duration_minutes: Math.round(avgDuration),
                estimated_savings_hours: Math.round(estimatedSavings * 10) / 10,
                automation_score: Math.round(score),
                suggestion: `Create ${p.tools.length >= 3 ? "orchestrator" : "skill"} for ${p.task_type}`,
                implementation: {
                    effort: avgComplexity < 4 ? "low" : avgComplexity < 7 ? "medium" : "high",
                    approach: p.tools.length >= 3 ? "skill + optional subagent" : "skill-based (markdown)",
                    steps: [
                        "Analyze common patterns in past executions",
                        `Document ${p.task_type} workflow`,
                        "Create automation template",
                        "Test with real scenarios"
                    ]
                }
            };
        });
        // Sort
        const sortBy = args.sort_by || "score";
        opportunities.sort((a, b) => {
            if (sortBy === "frequency")
                return b.frequency - a.frequency;
            if (sortBy === "time_savings")
                return b.estimated_savings_hours - a.estimated_savings_hours;
            return b.automation_score - a.automation_score; // Default: score
        });
        const totalSavings = opportunities.reduce((sum, o) => sum + o.estimated_savings_hours, 0);
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        opportunities,
                        total_potential_savings_hours: Math.round(totalSavings * 10) / 10
                    }, null, 2),
                },
            ],
        };
    }
    catch (error) {
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: false,
                        error: `Failed to get automation opportunities: ${error.message}`
                    }, null, 2)
                }
            ],
            isError: true
        };
    }
}
/**
 * Get Tool Usage Stats
 * Statistics about tool usage patterns
 */
export async function getToolUsageStats(args, brainPath) {
    try {
        // Read events
        let events = readAllEvents(brainPath);
        // Apply time range filter
        if (args.time_range) {
            const start = args.time_range.start ? new Date(args.time_range.start) : new Date(0);
            const end = args.time_range.end ? new Date(args.time_range.end) : new Date();
            events = filterEventsByTimeRange(events, start, end);
        }
        const taskEvents = events.filter(e => e.type === "task" || e.type === "workflow" || e.type === "mcp-usage");
        // Tool usage counts
        const toolStats = {};
        taskEvents.forEach(event => {
            const tools = event.data.tools_used || [];
            const duration = event.data.duration_minutes || 0;
            const context = event.data.task_type || event.data.workflow_name || "unknown";
            tools.forEach((tool) => {
                if (!toolStats[tool]) {
                    toolStats[tool] = {
                        usage_count: 0,
                        total_duration: 0,
                        contexts: {}
                    };
                }
                toolStats[tool].usage_count++;
                toolStats[tool].total_duration += duration;
                toolStats[tool].contexts[context] = (toolStats[tool].contexts[context] || 0) + 1;
            });
        });
        // Format results
        const tool_stats = Object.entries(toolStats).map(([tool, stats]) => {
            const mostCommonContext = Object.entries(stats.contexts)
                .sort((a, b) => b[1] - a[1])[0]?.[0] || "none";
            return {
                tool_name: tool,
                usage_count: stats.usage_count,
                avg_duration_minutes: stats.usage_count > 0 ? Math.round(stats.total_duration / stats.usage_count) : 0,
                most_common_context: mostCommonContext
            };
        }).sort((a, b) => b.usage_count - a.usage_count);
        // Tool combinations (if requested)
        let combinations;
        if (args.include_combinations) {
            const comboCounts = {};
            taskEvents.forEach(event => {
                const tools = (event.data.tools_used || []).sort();
                if (tools.length >= 2) {
                    // Generate pairs
                    for (let i = 0; i < tools.length - 1; i++) {
                        for (let j = i + 1; j < tools.length; j++) {
                            const pair = `${tools[i]}+${tools[j]}`;
                            comboCounts[pair] = (comboCounts[pair] || 0) + 1;
                        }
                    }
                }
            });
            combinations = Object.entries(comboCounts)
                .map(([pair, count]) => ({
                tools: pair.split("+"),
                frequency: count
            }))
                .sort((a, b) => b.frequency - a.frequency)
                .slice(0, 10); // Top 10 combinations
        }
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        tool_stats,
                        combinations
                    }, null, 2),
                },
            ],
        };
    }
    catch (error) {
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: false,
                        error: `Failed to get tool usage stats: ${error.message}`
                    }, null, 2)
                }
            ],
            isError: true
        };
    }
}
// Helper: Get ISO week number
function getWeekNumber(date) {
    const d = new Date(date);
    d.setHours(0, 0, 0, 0);
    d.setDate(d.getDate() + 4 - (d.getDay() || 7));
    const yearStart = new Date(d.getFullYear(), 0, 1);
    const weekNum = Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);
    return weekNum;
}
/**
 * PHASE 1.2 - ADVANCED ANALYTICS TOOLS
 * Added in workspace-brain-mcp v1.2 for enhanced BI capabilities
 */
/**
 * Analyze Workflow Efficiency
 * Detect workflow bottlenecks and inefficiencies
 */
export async function analyzeWorkflowEfficiency(args, brainPath) {
    try {
        // Read events
        let events = readAllEvents(brainPath);
        // Apply time range filter
        if (args.time_range) {
            const start = args.time_range.start ? new Date(args.time_range.start) : new Date(0);
            const end = args.time_range.end ? new Date(args.time_range.end) : new Date();
            events = filterEventsByTimeRange(events, start, end);
        }
        const workflowEvents = events.filter(e => e.type === "workflow" || e.type === "task");
        // Analyze by workflow
        const workflows = {};
        workflowEvents.forEach(event => {
            const name = event.data.workflow_name || event.data.task_type || "unknown";
            if (!workflows[name]) {
                workflows[name] = {
                    count: 0,
                    total_duration: 0,
                    avg_duration: 0,
                    completed: 0,
                    failed: 0,
                    blocked: 0,
                    bottlenecks: []
                };
            }
            workflows[name].count++;
            const duration = event.data.duration_minutes || 0;
            workflows[name].total_duration += duration;
            // Count outcomes
            if (event.data.outcome === "completed")
                workflows[name].completed++;
            else if (event.data.outcome === "failed")
                workflows[name].failed++;
            else if (event.data.outcome === "blocked")
                workflows[name].blocked++;
            // Detect bottlenecks (tasks taking >2x average)
            if (duration > 60) { // >1 hour is potential bottleneck
                workflows[name].bottlenecks.push(`Long duration: ${duration}min`);
            }
        });
        // Calculate averages and efficiency
        const analysis = Object.entries(workflows).map(([name, data]) => {
            data.avg_duration = data.count > 0 ? data.total_duration / data.count : 0;
            const successRate = data.count > 0 ? (data.completed / data.count) * 100 : 0;
            const efficiency = successRate > 80 ? "high" : successRate > 50 ? "medium" : "low";
            return {
                workflow_name: name,
                executions: data.count,
                avg_duration_minutes: Math.round(data.avg_duration),
                success_rate: Math.round(successRate),
                efficiency_rating: efficiency,
                completed: data.completed,
                failed: data.failed,
                blocked: data.blocked,
                bottlenecks: data.bottlenecks.slice(0, 3), // Top 3 bottlenecks
                recommendation: successRate < 80
                    ? "Review failure patterns and add error handling"
                    : data.avg_duration > 30
                        ? "Consider parallelization or automation"
                        : "Workflow is efficient"
            };
        }).sort((a, b) => b.executions - a.executions);
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        total_workflows: analysis.length,
                        analysis,
                        summary: {
                            high_efficiency: analysis.filter(w => w.efficiency_rating === "high").length,
                            medium_efficiency: analysis.filter(w => w.efficiency_rating === "medium").length,
                            low_efficiency: analysis.filter(w => w.efficiency_rating === "low").length
                        }
                    }, null, 2),
                },
            ],
        };
    }
    catch (error) {
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: false,
                        error: `Failed to analyze workflow efficiency: ${error.message}`
                    }, null, 2)
                }
            ],
            isError: true
        };
    }
}
/**
 * Identify High Value Automations
 * Advanced ROI analysis for automation candidates
 */
export async function identifyHighValueAutomations(args, brainPath) {
    try {
        // Leverage existing automation opportunities tool
        const opportunities = await getAutomationOpportunities({
            time_range: args.time_range,
            min_frequency: args.min_frequency || 2, // Lower threshold for high-value
            min_duration: args.min_duration || 10,
            sort_by: "score"
        }, brainPath);
        const opportunitiesData = JSON.parse(opportunities.content[0].text);
        if (!opportunitiesData.success) {
            return opportunities;
        }
        // Enhance with ROI calculation
        const highValueTargets = opportunitiesData.opportunities.map((opp) => {
            // ROI = (time_savings * $value_per_hour) / implementation_effort_hours
            const implementationHours = opp.implementation.effort === "low" ? 2 :
                opp.implementation.effort === "medium" ? 5 :
                    10; // high effort
            const roi = opp.estimated_savings_hours / implementationHours;
            const value_category = roi > 5 ? "very-high" :
                roi > 2 ? "high" :
                    roi > 1 ? "medium" :
                        "low";
            return {
                ...opp,
                roi: Math.round(roi * 10) / 10,
                value_category,
                implementation_hours: implementationHours,
                break_even_days: Math.ceil(implementationHours / (opp.estimated_savings_hours / 30)), // Assumes monthly recurrence
                recommendation: roi > 2
                    ? "PRIORITY: High ROI automation target"
                    : roi > 1
                        ? "CONSIDER: Positive ROI, implement when capacity allows"
                        : "DEFER: Low ROI, focus on higher-value targets first"
            };
        }).sort((a, b) => b.roi - a.roi);
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        high_value_automations: highValueTargets,
                        summary: {
                            very_high_value: highValueTargets.filter((t) => t.value_category === "very-high").length,
                            high_value: highValueTargets.filter((t) => t.value_category === "high").length,
                            medium_value: highValueTargets.filter((t) => t.value_category === "medium").length,
                            low_value: highValueTargets.filter((t) => t.value_category === "low").length
                        }
                    }, null, 2),
                },
            ],
        };
    }
    catch (error) {
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: false,
                        error: `Failed to identify high-value automations: ${error.message}`
                    }, null, 2)
                }
            ],
            isError: true
        };
    }
}
/**
 * Generate Insights Report
 * Generate actionable insights from telemetry data
 */
export async function generateInsightsReport(args, brainPath) {
    try {
        // Read events
        let events = readAllEvents(brainPath);
        // Apply time range filter
        const timeRange = args.time_range || {};
        const start = timeRange.start ? new Date(timeRange.start) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // Last 30 days
        const end = timeRange.end ? new Date(timeRange.end) : new Date();
        events = filterEventsByTimeRange(events, start, end);
        const taskEvents = events.filter(e => e.type === "task" || e.type === "workflow");
        // Generate insights
        const insights = [];
        // Productivity insights
        const totalTasks = taskEvents.length;
        const avgDuration = totalTasks > 0
            ? taskEvents.reduce((sum, e) => sum + (e.data.duration_minutes || 0), 0) / totalTasks
            : 0;
        if (totalTasks > 10 && avgDuration > 45) {
            insights.push({
                category: "productivity",
                insight: `Average task duration is ${Math.round(avgDuration)} minutes, which is above optimal range`,
                impact: "High - Extended task durations reduce overall throughput",
                action: "Break down large tasks into smaller subtasks or parallelize work",
                priority: "high"
            });
        }
        // Success rate insights
        const completed = taskEvents.filter(e => e.data.outcome === "completed").length;
        const failed = taskEvents.filter(e => e.data.outcome === "failed").length;
        const successRate = totalTasks > 0 ? (completed / totalTasks) * 100 : 0;
        if (successRate < 80 && totalTasks > 5) {
            insights.push({
                category: "quality",
                insight: `Task success rate is ${Math.round(successRate)}%, below target of 80%`,
                impact: "Medium - Failed tasks waste time and require rework",
                action: "Add validation checks and error handling to workflows",
                priority: "medium"
            });
        }
        // Tool usage insights
        const toolUsage = {};
        taskEvents.forEach(e => {
            (e.data.tools_used || []).forEach((tool) => {
                toolUsage[tool] = (toolUsage[tool] || 0) + 1;
            });
        });
        const topTools = Object.entries(toolUsage)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3);
        if (topTools.length > 0) {
            insights.push({
                category: "tools",
                insight: `Most used tools: ${topTools.map(([t, c]) => `${t} (${c} uses)`).join(", ")}`,
                impact: "Low - Informational",
                action: "Ensure these tools are well-documented and optimized",
                priority: "low"
            });
        }
        // Pattern insights
        const patterns = {};
        taskEvents.forEach(e => {
            const pattern = e.data.task_type || "unknown";
            patterns[pattern] = (patterns[pattern] || 0) + 1;
        });
        const repeatedPatterns = Object.entries(patterns)
            .filter(([_, count]) => count >= 3)
            .sort((a, b) => b[1] - a[1]);
        if (repeatedPatterns.length > 0) {
            insights.push({
                category: "automation",
                insight: `Found ${repeatedPatterns.length} repeated task patterns (â‰¥3 occurrences each)`,
                impact: "High - Repeated tasks are prime automation candidates",
                action: `Consider automating: ${repeatedPatterns.slice(0, 3).map(([p]) => p).join(", ")}`,
                priority: "high"
            });
        }
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        period: {
                            start: start.toISOString(),
                            end: end.toISOString()
                        },
                        total_insights: insights.length,
                        insights: insights.sort((a, b) => {
                            const priorityOrder = { high: 3, medium: 2, low: 1 };
                            return (priorityOrder[b.priority] || 0) - (priorityOrder[a.priority] || 0);
                        }),
                        summary: {
                            high_priority: insights.filter(i => i.priority === "high").length,
                            medium_priority: insights.filter(i => i.priority === "medium").length,
                            low_priority: insights.filter(i => i.priority === "low").length
                        }
                    }, null, 2),
                },
            ],
        };
    }
    catch (error) {
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: false,
                        error: `Failed to generate insights report: ${error.message}`
                    }, null, 2)
                }
            ],
            isError: true
        };
    }
}
/**
 * Track Goal Velocity
 * Track goal completion trends and velocity
 */
export async function trackGoalVelocity(args, brainPath) {
    try {
        // Read events
        let events = readAllEvents(brainPath);
        // Apply time range filter
        const timeRange = args.time_range || {};
        const start = timeRange.start ? new Date(timeRange.start) : new Date(Date.now() - 90 * 24 * 60 * 60 * 1000); // Last 90 days
        const end = timeRange.end ? new Date(timeRange.end) : new Date();
        events = filterEventsByTimeRange(events, start, end);
        const goalEvents = events.filter(e => e.type === "task" &&
            (e.data.metadata?.goal_id || e.data.metadata?.goal_name));
        // Group by goal
        const goals = {};
        goalEvents.forEach(event => {
            const goalId = event.data.metadata?.goal_id || event.data.metadata?.goal_name;
            if (!goals[goalId]) {
                goals[goalId] = {
                    tasks_completed: 0,
                    total_duration: 0,
                    start_date: event.timestamp,
                    last_activity: event.timestamp,
                    avg_task_duration: 0
                };
            }
            goals[goalId].tasks_completed++;
            goals[goalId].total_duration += event.data.duration_minutes || 0;
            goals[goalId].last_activity = event.timestamp;
        });
        // Calculate velocity metrics
        const velocity = Object.entries(goals).map(([goalId, data]) => {
            const startDate = new Date(data.start_date);
            const lastDate = new Date(data.last_activity);
            const daysSinceStart = Math.max(1, Math.ceil((lastDate.getTime() - startDate.getTime()) / (24 * 60 * 60 * 1000)));
            const tasksPerWeek = (data.tasks_completed / daysSinceStart) * 7;
            data.avg_task_duration = data.tasks_completed > 0 ? data.total_duration / data.tasks_completed : 0;
            const velocityTrend = tasksPerWeek > 7 ? "accelerating" :
                tasksPerWeek > 3 ? "steady" :
                    tasksPerWeek > 1 ? "slow" :
                        "stalled";
            return {
                goal_id: goalId,
                tasks_completed: data.tasks_completed,
                avg_task_duration_minutes: Math.round(data.avg_task_duration),
                tasks_per_week: Math.round(tasksPerWeek * 10) / 10,
                velocity_trend: velocityTrend,
                days_active: daysSinceStart,
                total_hours: Math.round((data.total_duration / 60) * 10) / 10,
                last_activity: data.last_activity,
                recommendation: velocityTrend === "stalled" ? "Goal may be blocked - review and re-prioritize" :
                    velocityTrend === "slow" ? "Consider breaking into smaller milestones" :
                        velocityTrend === "accelerating" ? "Excellent progress - maintain momentum" :
                            "Good progress - continue current approach"
            };
        }).sort((a, b) => b.tasks_per_week - a.tasks_per_week);
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        total_goals_tracked: velocity.length,
                        velocity_by_goal: velocity,
                        summary: {
                            accelerating: velocity.filter(g => g.velocity_trend === "accelerating").length,
                            steady: velocity.filter(g => g.velocity_trend === "steady").length,
                            slow: velocity.filter(g => g.velocity_trend === "slow").length,
                            stalled: velocity.filter(g => g.velocity_trend === "stalled").length
                        }
                    }, null, 2),
                },
            ],
        };
    }
    catch (error) {
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: false,
                        error: `Failed to track goal velocity: ${error.message}`
                    }, null, 2)
                }
            ],
            isError: true
        };
    }
}
/**
 * Analyze MCP Usage Patterns
 * Analyze MCP tool usage and effectiveness
 */
export async function analyzeMcpUsagePatterns(args, brainPath) {
    try {
        // Read events
        let events = readAllEvents(brainPath);
        // Apply time range filter
        if (args.time_range) {
            const start = args.time_range.start ? new Date(args.time_range.start) : new Date(0);
            const end = args.time_range.end ? new Date(args.time_range.end) : new Date();
            events = filterEventsByTimeRange(events, start, end);
        }
        const mcpEvents = events.filter(e => e.type === "mcp-usage" || (e.data.tools_used && e.data.tools_used.length > 0));
        // Analyze MCP tool usage
        const mcpStats = {};
        mcpEvents.forEach(event => {
            const tools = event.data.tools_used || [event.data.mcp_tool];
            tools.forEach((tool) => {
                if (!tool)
                    return;
                if (!mcpStats[tool]) {
                    mcpStats[tool] = {
                        usage_count: 0,
                        success_count: 0,
                        failure_count: 0,
                        avg_duration: 0,
                        total_duration: 0
                    };
                }
                mcpStats[tool].usage_count++;
                if (event.data.outcome === "completed")
                    mcpStats[tool].success_count++;
                if (event.data.outcome === "failed")
                    mcpStats[tool].failure_count++;
                mcpStats[tool].total_duration += event.data.duration_minutes || 0;
            });
        });
        // Calculate effectiveness metrics
        const analysis = Object.entries(mcpStats).map(([tool, stats]) => {
            stats.avg_duration = stats.usage_count > 0 ? stats.total_duration / stats.usage_count : 0;
            const successRate = stats.usage_count > 0 ? (stats.success_count / stats.usage_count) * 100 : 0;
            const effectiveness = successRate > 90 ? "excellent" :
                successRate > 75 ? "good" :
                    successRate > 50 ? "fair" :
                        "poor";
            return {
                mcp_tool: tool,
                usage_count: stats.usage_count,
                success_rate: Math.round(successRate),
                effectiveness,
                avg_duration_minutes: Math.round(stats.avg_duration),
                total_hours: Math.round((stats.total_duration / 60) * 10) / 10,
                recommendation: successRate < 75 ? "High failure rate - review error patterns" :
                    stats.avg_duration > 10 ? "Consider performance optimization" :
                        "Tool performing well"
            };
        }).sort((a, b) => b.usage_count - a.usage_count);
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        total_tools_analyzed: analysis.length,
                        mcp_usage_analysis: analysis,
                        summary: {
                            excellent: analysis.filter(t => t.effectiveness === "excellent").length,
                            good: analysis.filter(t => t.effectiveness === "good").length,
                            fair: analysis.filter(t => t.effectiveness === "fair").length,
                            poor: analysis.filter(t => t.effectiveness === "poor").length
                        }
                    }, null, 2),
                },
            ],
        };
    }
    catch (error) {
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: false,
                        error: `Failed to analyze MCP usage patterns: ${error.message}`
                    }, null, 2)
                }
            ],
            isError: true
        };
    }
}
/**
 * Create Custom Dashboard
 * Generate custom analytics dashboards
 */
export async function createCustomDashboard(args, brainPath) {
    try {
        const dashboardType = args.dashboard_type || "productivity";
        // Read events
        let events = readAllEvents(brainPath);
        // Apply time range filter
        const timeRange = args.time_range || {};
        const start = timeRange.start ? new Date(timeRange.start) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
        const end = timeRange.end ? new Date(timeRange.end) : new Date();
        events = filterEventsByTimeRange(events, start, end);
        let dashboard = {};
        switch (dashboardType) {
            case "productivity":
                const taskEvents = events.filter(e => e.type === "task" || e.type === "workflow");
                dashboard = {
                    type: "productivity",
                    period: { start: start.toISOString(), end: end.toISOString() },
                    metrics: {
                        total_tasks: taskEvents.length,
                        completed: taskEvents.filter(e => e.data.outcome === "completed").length,
                        in_progress: taskEvents.filter(e => !e.data.outcome).length,
                        failed: taskEvents.filter(e => e.data.outcome === "failed").length,
                        total_hours: Math.round(taskEvents.reduce((sum, e) => sum + (e.data.duration_minutes || 0), 0) / 60 * 10) / 10,
                        avg_task_duration: taskEvents.length > 0
                            ? Math.round(taskEvents.reduce((sum, e) => sum + (e.data.duration_minutes || 0), 0) / taskEvents.length)
                            : 0
                    },
                    top_task_types: Object.entries(taskEvents.reduce((acc, e) => {
                        const type = e.data.task_type || "unknown";
                        acc[type] = (acc[type] || 0) + 1;
                        return acc;
                    }, {})).sort((a, b) => b[1] - a[1]).slice(0, 5)
                };
                break;
            case "system_health":
                const allEvents = events;
                const failedEvents = allEvents.filter(e => e.data.outcome === "failed");
                dashboard = {
                    type: "system_health",
                    period: { start: start.toISOString(), end: end.toISOString() },
                    metrics: {
                        total_events: allEvents.length,
                        error_rate: allEvents.length > 0 ? Math.round((failedEvents.length / allEvents.length) * 100) : 0,
                        uptime_percentage: allEvents.length > 0 ? Math.round(((allEvents.length - failedEvents.length) / allEvents.length) * 100) : 100,
                        critical_errors: failedEvents.filter(e => e.data.metadata?.severity === "critical").length,
                        warnings: failedEvents.filter(e => e.data.metadata?.severity === "warning").length
                    },
                    health_status: allEvents.length > 0 && (failedEvents.length / allEvents.length) < 0.05 ? "healthy" : "degraded"
                };
                break;
            case "goals":
                const goalEvents = events.filter(e => e.data.metadata?.goal_id || e.data.metadata?.goal_name);
                const goalGroups = goalEvents.reduce((acc, e) => {
                    const goalId = e.data.metadata?.goal_id || e.data.metadata?.goal_name;
                    acc[goalId] = (acc[goalId] || 0) + 1;
                    return acc;
                }, {});
                dashboard = {
                    type: "goals",
                    period: { start: start.toISOString(), end: end.toISOString() },
                    metrics: {
                        active_goals: Object.keys(goalGroups).length,
                        total_goal_tasks: goalEvents.length,
                        avg_tasks_per_goal: Object.keys(goalGroups).length > 0
                            ? Math.round(goalEvents.length / Object.keys(goalGroups).length)
                            : 0
                    },
                    goals_by_activity: Object.entries(goalGroups)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 10)
                };
                break;
            default:
                return {
                    content: [
                        {
                            type: "text",
                            text: JSON.stringify({
                                success: false,
                                error: `Unknown dashboard type: ${dashboardType}. Valid types: productivity, system_health, goals`
                            }, null, 2)
                        }
                    ],
                    isError: true
                };
        }
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: true,
                        dashboard
                    }, null, 2),
                },
            ],
        };
    }
    catch (error) {
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        success: false,
                        error: `Failed to create custom dashboard: ${error.message}`
                    }, null, 2)
                }
            ],
            isError: true
        };
    }
}
//# sourceMappingURL=analytics.js.map