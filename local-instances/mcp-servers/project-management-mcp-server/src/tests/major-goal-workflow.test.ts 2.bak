/**
 * Integration Tests: Goal 006 - Major Goal Workflow Tools
 *
 * Tests for:
 * - create_major_goal: Create major goals in components/sub-areas
 * - promote_to_major_goal: Promote from brainstorming/potential goals
 * - handoff_to_spec_driven: Prepare handoff context
 * - update_major_goal_progress: Aggregate progress from sub-goals
 * - get_major_goal_status: Get detailed status view
 */

import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import {
  createMajorGoal,
  promoteToMajorGoal,
  handoffToSpecDriven,
  updateMajorGoalProgress,
  getMajorGoalStatus,
} from '../tools/major-goal-workflow';

describe('Goal 006: Major Goal Workflow Tools', () => {
  let tempDir: string;
  let projectPath: string;

  beforeEach(() => {
    // Create temporary project structure
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'major-goal-test-'));
    projectPath = tempDir;

    // Create basic project structure
    const goalsPath = path.join(projectPath, '02-goals-and-roadmap');
    const componentsPath = path.join(goalsPath, 'components');
    fs.mkdirSync(componentsPath, { recursive: true });

    // Create test component
    const componentPath = path.join(componentsPath, 'test-component');
    fs.mkdirSync(componentPath);
    fs.mkdirSync(path.join(componentPath, 'major-goals'));

    // Create test sub-area
    const subAreasPath = path.join(componentPath, 'sub-areas');
    fs.mkdirSync(subAreasPath);
    const subAreaPath = path.join(subAreasPath, 'test-sub-area');
    fs.mkdirSync(subAreaPath);
    fs.mkdirSync(path.join(subAreaPath, 'major-goals'));
  });

  afterEach(() => {
    // Clean up
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });

  // ============================================================================
  // TEST: create_major_goal
  // ============================================================================

  describe('create_major_goal', () => {
    it('should create major goal in component', async () => {
      const result = await createMajorGoal({
        projectPath,
        componentId: 'test-component',
        goalName: 'Implement Authentication System',
        description: 'Build secure authentication with OAuth2 and JWT',
        purpose: 'Enable secure user access and identity management',
        successCriteria: [
          'OAuth2 integration working',
          'JWT tokens generated correctly',
          'Session management implemented',
        ],
        estimatedEffort: '3 weeks',
        priority: 'High',
        owner: 'Security Team',
        targetDate: '2025-12-01',
      });

      expect(result.success).toBe(true);
      expect(result.goalId).toBe('001');
      expect(result.handoffReady).toBe(true);
      expect(result.handoffContext).toBeDefined();
      expect(result.handoffContext?.targetServer).toBe('spec-driven-mcp');

      // Verify folder created
      const goalFolderPath = path.join(
        projectPath,
        '02-goals-and-roadmap',
        'components',
        'test-component',
        'major-goals',
        '001-implement-authentication-system'
      );
      expect(fs.existsSync(goalFolderPath)).toBe(true);

      // Verify GOAL-STATUS.md created
      const statusFilePath = path.join(goalFolderPath, 'GOAL-STATUS.md');
      expect(fs.existsSync(statusFilePath)).toBe(true);

      const statusContent = fs.readFileSync(statusFilePath, 'utf-8');
      expect(statusContent).toContain('Implement Authentication System');
      expect(statusContent).toContain('OAuth2 integration working');
      expect(statusContent).toContain('Priority: High');
      expect(statusContent).toContain('Owner: Security Team');
    });

    it('should create major goal in sub-area', async () => {
      const result = await createMajorGoal({
        projectPath,
        componentId: 'test-component',
        subAreaId: 'test-sub-area',
        goalName: 'Build API Gateway',
        description: 'Centralized API gateway with rate limiting',
        purpose: 'Improve API management and security',
        successCriteria: ['Rate limiting active', 'Load balancing working'],
        estimatedEffort: '2 weeks',
        priority: 'Medium',
      });

      expect(result.success).toBe(true);
      expect(result.goalId).toBe('001');

      // Verify created in sub-area
      const goalFolderPath = path.join(
        projectPath,
        '02-goals-and-roadmap',
        'components',
        'test-component',
        'sub-areas',
        'test-sub-area',
        'major-goals',
        '001-build-api-gateway'
      );
      expect(fs.existsSync(goalFolderPath)).toBe(true);
    });

    it('should generate sequential goal IDs', async () => {
      // Create first goal
      const result1 = await createMajorGoal({
        projectPath,
        componentId: 'test-component',
        goalName: 'Goal One',
        description: 'First goal',
        purpose: 'Testing sequential IDs',
      });

      expect(result1.goalId).toBe('001');

      // Create second goal
      const result2 = await createMajorGoal({
        projectPath,
        componentId: 'test-component',
        goalName: 'Goal Two',
        description: 'Second goal',
        purpose: 'Testing sequential IDs',
      });

      expect(result2.goalId).toBe('002');
    });

    it('should fail if component does not exist', async () => {
      const result = await createMajorGoal({
        projectPath,
        componentId: 'non-existent-component',
        goalName: 'Test Goal',
        description: 'This should fail',
        purpose: 'Testing error handling',
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('does not exist');
    });

    it('should fail if sub-area does not exist', async () => {
      const result = await createMajorGoal({
        projectPath,
        componentId: 'test-component',
        subAreaId: 'non-existent-sub-area',
        goalName: 'Test Goal',
        description: 'This should fail',
        purpose: 'Testing error handling',
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('does not exist');
    });
  });

  // ============================================================================
  // TEST: promote_to_major_goal
  // ============================================================================

  describe('promote_to_major_goal', () => {
    it('should promote potential goal to major goal', async () => {
      // Create potential goal file
      const brainstormingPath = path.join(projectPath, 'brainstorming', 'future-goals', 'potential-goals');
      fs.mkdirSync(brainstormingPath, { recursive: true });

      const potentialGoalPath = path.join(brainstormingPath, 'mobile-app.md');
      const potentialGoalContent = `# Goal: Build Mobile App

**Description:** Native mobile application for iOS and Android

**Purpose:** Expand platform reach to mobile users

**Success Criteria:**
- iOS app published to App Store
- Android app published to Play Store
- Push notifications working
- Offline mode implemented

**Estimated Effort:** 8 weeks

**Priority:** High
`;

      fs.writeFileSync(potentialGoalPath, potentialGoalContent, 'utf-8');

      // Promote to major goal
      const result = await promoteToMajorGoal({
        projectPath,
        componentId: 'test-component',
        sourceType: 'potential-goal',
        sourcePath: potentialGoalPath,
        goalName: 'Build Mobile App',
        description: 'Native mobile application for iOS and Android',
        purpose: 'Expand platform reach to mobile users',
        owner: 'Mobile Team',
      });

      expect(result.success).toBe(true);
      expect(result.goalId).toBe('001');
      expect(result.sourceMarked).toBe(true);
      expect(result.handoffReady).toBe(true);

      // Verify potential goal marked as promoted
      const updatedContent = fs.readFileSync(potentialGoalPath, 'utf-8');
      expect(updatedContent).toContain('## ✅ Promoted to Major Goal');
      expect(updatedContent).toContain('Major Goal ID: 001');
      expect(updatedContent).toContain('components/test-component/major-goals/001');
    });

    it('should auto-extract data from potential goal', async () => {
      // Create potential goal with rich data
      const brainstormingPath = path.join(projectPath, 'brainstorming', 'future-goals', 'potential-goals');
      fs.mkdirSync(brainstormingPath, { recursive: true });

      const potentialGoalPath = path.join(brainstormingPath, 'analytics.md');
      const potentialGoalContent = `# Advanced Analytics Dashboard

**Description:** Real-time analytics with custom visualizations

**Expected Value:** Data-driven decision making for stakeholders

**Success Criteria:**
- Real-time data streaming
- Custom chart builder
- Export to PDF/Excel

**Effort:** 6 weeks

**Priority:** Medium
`;

      fs.writeFileSync(potentialGoalPath, potentialGoalContent, 'utf-8');

      // Promote with minimal args (should auto-extract)
      const result = await promoteToMajorGoal({
        projectPath,
        componentId: 'test-component',
        sourceType: 'potential-goal',
        sourcePath: potentialGoalPath,
        goalName: '', // Should be extracted
        description: '', // Should be extracted
        purpose: '', // Should be extracted
      });

      expect(result.success).toBe(true);

      // Verify extracted data was used
      const goalFolderPath = path.join(
        projectPath,
        '02-goals-and-roadmap',
        'components',
        'test-component',
        'major-goals',
        '001-advanced-analytics-dashboard'
      );

      const statusFilePath = path.join(goalFolderPath, 'GOAL-STATUS.md');
      const statusContent = fs.readFileSync(statusFilePath, 'utf-8');

      expect(statusContent).toContain('Advanced Analytics Dashboard');
      expect(statusContent).toContain('Real-time analytics with custom visualizations');
      expect(statusContent).toContain('Real-time data streaming');
      expect(statusContent).toContain('Priority: Medium');
    });

    it('should promote from brainstorming idea (direct)', async () => {
      const result = await promoteToMajorGoal({
        projectPath,
        componentId: 'test-component',
        sourceType: 'brainstorming',
        goalName: 'Implement Caching Layer',
        description: 'Redis-based caching for performance',
        purpose: 'Reduce database load and improve response times',
        successCriteria: ['Cache hit rate > 80%', 'Response time < 100ms'],
        estimatedEffort: '2 weeks',
        priority: 'High',
      });

      expect(result.success).toBe(true);
      expect(result.goalId).toBe('001');
      expect(result.handoffReady).toBe(true);
    });

    it('should promote with direct input', async () => {
      const result = await promoteToMajorGoal({
        projectPath,
        componentId: 'test-component',
        sourceType: 'direct',
        goalName: 'Security Audit',
        description: 'Comprehensive security review',
        purpose: 'Identify and fix vulnerabilities',
        priority: 'Critical',
      });

      expect(result.success).toBe(true);
      expect(result.sourceMarked).toBe(true); // Direct promotion is immediately marked
    });

    it('should fail if potential goal file not found', async () => {
      const result = await promoteToMajorGoal({
        projectPath,
        componentId: 'test-component',
        sourceType: 'potential-goal',
        sourcePath: '/non/existent/file.md',
        goalName: 'Test',
        description: 'Test',
        purpose: 'Test',
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('not found');
    });
  });

  // ============================================================================
  // TEST: handoff_to_spec_driven
  // ============================================================================

  describe('handoff_to_spec_driven', () => {
    beforeEach(async () => {
      // Create a major goal to handoff
      await createMajorGoal({
        projectPath,
        componentId: 'test-component',
        goalName: 'Build Payment System',
        description: 'Stripe integration for payments',
        purpose: 'Enable monetization',
        successCriteria: ['Stripe connected', 'Payment flow working', 'Refunds supported'],
        estimatedEffort: '4 weeks',
        priority: 'Critical',
      });
    });

    it('should prepare handoff context for Spec-Driven MCP', async () => {
      const result = await handoffToSpecDriven({
        projectPath,
        goalId: '001',
        componentId: 'test-component',
        additionalContext: 'Focus on security and PCI compliance',
      });

      expect(result.success).toBe(true);
      expect(result.handoffContext).toBeDefined();
      expect(result.handoffContext?.sourceServer).toBe('ai-planning-mcp');
      expect(result.handoffContext?.targetServer).toBe('spec-driven-mcp');
      expect(result.handoffContext?.handoffType).toBe('major-goal-to-decomposition');
      expect(result.handoffContext?.context.majorGoal).toBeDefined();
      expect(result.handoffContext?.instructions).toContain('Build Payment System');
      expect(result.handoffContext?.instructions).toContain('Focus on security and PCI compliance');
    });

    it('should fail if major goal not found', async () => {
      const result = await handoffToSpecDriven({
        projectPath,
        goalId: '999',
        componentId: 'test-component',
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('not found');
    });
  });

  // ============================================================================
  // TEST: update_major_goal_progress
  // ============================================================================

  describe('update_major_goal_progress', () => {
    beforeEach(async () => {
      // Create a major goal
      await createMajorGoal({
        projectPath,
        componentId: 'test-component',
        goalName: 'Implement Search Feature',
        description: 'Full-text search with Elasticsearch',
        purpose: 'Improve content discoverability',
      });
    });

    it('should calculate progress from sub-goals', async () => {
      const result = await updateMajorGoalProgress({
        projectPath,
        goalId: '001',
        componentId: 'test-component',
      });

      expect(result.success).toBe(true);
      expect(result.progress).toBeDefined();
      expect(result.progress?.percentage).toBeDefined();
      expect(result.progress?.status).toBeDefined();
      expect(result.progress?.completedSubGoals).toBeDefined();
      expect(result.progress?.totalSubGoals).toBeDefined();
    });

    it('should fail if major goal not found', async () => {
      const result = await updateMajorGoalProgress({
        projectPath,
        goalId: '999',
        componentId: 'test-component',
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('not found');
    });
  });

  // ============================================================================
  // TEST: get_major_goal_status
  // ============================================================================

  describe('get_major_goal_status', () => {
    beforeEach(async () => {
      // Create a major goal
      await createMajorGoal({
        projectPath,
        componentId: 'test-component',
        goalName: 'Data Migration Tool',
        description: 'Migrate legacy data to new schema',
        purpose: 'Complete database modernization',
        priority: 'High',
        owner: 'Data Team',
      });
    });

    it('should get detailed major goal status', async () => {
      const result = await getMajorGoalStatus({
        projectPath,
        goalId: '001',
        componentId: 'test-component',
      });

      expect(result.success).toBe(true);
      expect(result.status).toBeDefined();
      expect(result.status?.goalId).toBe('001');
      expect(result.status?.goalName).toBe('Data Migration Tool');
      expect(result.status?.progress).toBeDefined();
      expect(result.status?.priority).toBeDefined();
      expect(result.status?.owner).toBeDefined();
      expect(result.status?.subGoals).toBeDefined();
      expect(result.status?.risks).toBeDefined();
      expect(result.status?.blockers).toBeDefined();
    });

    it('should fail if major goal not found', async () => {
      const result = await getMajorGoalStatus({
        projectPath,
        goalId: '999',
        componentId: 'test-component',
      });

      expect(result.success).toBe(false);
      expect(result.error).toContain('not found');
    });
  });

  // ============================================================================
  // TEST: Integration - Full Workflow
  // ============================================================================

  describe('Integration: Full Major Goal Workflow', () => {
    it('should complete full workflow: potential goal → major goal → handoff', async () => {
      // Step 1: Create potential goal
      const brainstormingPath = path.join(projectPath, 'brainstorming', 'future-goals', 'potential-goals');
      fs.mkdirSync(brainstormingPath, { recursive: true });

      const potentialGoalPath = path.join(brainstormingPath, 'ai-integration.md');
      const potentialGoalContent = `# AI Integration

**Description:** Integrate GPT-4 for intelligent features

**Purpose:** Add AI-powered content generation and analysis

**Success Criteria:**
- GPT-4 API integrated
- Content generation working
- Cost monitoring in place

**Estimated Effort:** 5 weeks

**Priority:** High
`;

      fs.writeFileSync(potentialGoalPath, potentialGoalContent, 'utf-8');

      // Step 2: Promote to major goal
      const promoteResult = await promoteToMajorGoal({
        projectPath,
        componentId: 'test-component',
        sourceType: 'potential-goal',
        sourcePath: potentialGoalPath,
        goalName: 'AI Integration',
        description: 'Integrate GPT-4 for intelligent features',
        purpose: 'Add AI-powered content generation and analysis',
        owner: 'AI Team',
      });

      expect(promoteResult.success).toBe(true);
      expect(promoteResult.sourceMarked).toBe(true);
      expect(promoteResult.handoffReady).toBe(true);

      // Step 3: Prepare handoff to Spec-Driven MCP
      const handoffResult = await handoffToSpecDriven({
        projectPath,
        goalId: promoteResult.goalId!,
        componentId: 'test-component',
        additionalContext: 'Consider token usage optimization',
      });

      expect(handoffResult.success).toBe(true);
      expect(handoffResult.handoffContext?.context.majorGoal.name).toBe('AI Integration');

      // Step 4: Get status
      const statusResult = await getMajorGoalStatus({
        projectPath,
        goalId: promoteResult.goalId!,
        componentId: 'test-component',
      });

      expect(statusResult.success).toBe(true);
      expect(statusResult.status?.goalName).toBe('AI Integration');

      // Step 5: Update progress (no sub-goals yet, so 0%)
      const progressResult = await updateMajorGoalProgress({
        projectPath,
        goalId: promoteResult.goalId!,
        componentId: 'test-component',
      });

      expect(progressResult.success).toBe(true);
      expect(progressResult.progress?.percentage).toBe(0);

      // Verify potential goal marked correctly
      const updatedPotentialGoal = fs.readFileSync(potentialGoalPath, 'utf-8');
      expect(updatedPotentialGoal).toContain('## ✅ Promoted to Major Goal');
      expect(updatedPotentialGoal).toContain(`Major Goal ID: ${promoteResult.goalId}`);
    });

    it('should handle concurrent goal creation in same component', async () => {
      // Create 3 goals concurrently
      const results = await Promise.all([
        createMajorGoal({
          projectPath,
          componentId: 'test-component',
          goalName: 'Goal A',
          description: 'First concurrent goal',
          purpose: 'Testing concurrency',
        }),
        createMajorGoal({
          projectPath,
          componentId: 'test-component',
          goalName: 'Goal B',
          description: 'Second concurrent goal',
          purpose: 'Testing concurrency',
        }),
        createMajorGoal({
          projectPath,
          componentId: 'test-component',
          goalName: 'Goal C',
          description: 'Third concurrent goal',
          purpose: 'Testing concurrency',
        }),
      ]);

      // All should succeed
      expect(results.every(r => r.success)).toBe(true);

      // Should have unique IDs (001, 002, 003 in some order)
      const goalIds = results.map(r => r.goalId).sort();
      expect(goalIds).toEqual(['001', '002', '003']);
    });
  });

  // ============================================================================
  // TEST: Performance
  // ============================================================================

  describe('Performance', () => {
    it('should create major goal in < 2 seconds', async () => {
      const start = Date.now();

      await createMajorGoal({
        projectPath,
        componentId: 'test-component',
        goalName: 'Performance Test Goal',
        description: 'Testing creation speed',
        purpose: 'Validate performance requirements',
      });

      const duration = Date.now() - start;
      expect(duration).toBeLessThan(2000);
    });

    it('should prepare handoff in < 2 seconds', async () => {
      // Create goal first
      await createMajorGoal({
        projectPath,
        componentId: 'test-component',
        goalName: 'Handoff Performance Test',
        description: 'Testing handoff speed',
        purpose: 'Validate performance requirements',
      });

      const start = Date.now();

      await handoffToSpecDriven({
        projectPath,
        goalId: '001',
        componentId: 'test-component',
      });

      const duration = Date.now() - start;
      expect(duration).toBeLessThan(2000);
    });
  });
});
